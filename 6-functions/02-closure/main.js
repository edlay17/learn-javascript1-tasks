'use strict'

/*
Проблема: JS относится к языкам, в которых фукнцию можно присвоить переменной, свойству, передать параметров, вернуть и т.д.
Нужно как-то понимать какие значения переменных и в какой момент использовать.

Решение: Замыкания


при объявлении Function Declaration она попадает в лексическое окружение только сама, не выполняется

у каждой функции при рождении есть свойство [[Environment]], которое содержит место (окружение), в котором она была создана

когда функция выполняется, создается ее собственное внутреннее лексическое окружение, в которое попадают все локальные переменные

так же у каждого лексического окружения есть ссылка на внешнее, у функции это как раз [[Environment]]

если функция возвращает вложенную функцию, то вложенная функция так же "рождается" в момент вызова родительской
и получает свойство [[Environment]], которое ссылается на лексическое окружение родительской функции

в итоге при вызове дочерней функции создается новое лексическое окружение, которое принимает значение, лежащее в [[Environment]],
которое ведет на лексическое окружение родительской функции

лексическое окружение дочерней функции -> родительской (место создания дочерней) -> глобальное (место создания родительской)

Замыкание - функция, которая способна запомнить вшнение переменные и получить к ним доступ. Все функции в JS - замыкания.
Так реализовано в JS, во многих других языках это реализовано иначе.


Лексическое окружение существует для любых блоков и созадется в момент их выполнения.
У каждой итерации цикла свое лексическое окружение.

можно использовать фигурные скобки для изоляции всего или части скрипта во внутреннее лекическое окружение
раньше для этого использовались «immediately-invoked function expressions» (аббревиатура IIFE) функции, которые запускаются сразу после объявления
для этого, как один из вариантов, функцию надо оберунть () скобками, чтобы показать JSу, что это function expression

Объект лексического окружения умирает, когда становится недоступным (как и любой другой объект)

Движки пытаются оптимизировать и не хранить в памяти переменные, которые не используются
Одним из побочных эффектов движка V8 является невозможность увидеть эти переменные в отладке
Это может привести к непоняткам при отладке, особенно при наличии других переменных с таким же названием, можно увидеть не ту переменную
 */

let name = "1";

function worker() {
    return function() {
        console.log(name);
    }
}

name = 2;

const test = worker();

name = 3

test(); // 3

name = 4;



/*
Сумма с помощью замыканий
важность: 4
Напишите функцию sum, которая работает таким образом: sum(a)(b) = a+b.

Да, именно таким образом, используя двойные круглые скобки (не опечатка).

Например:

sum(1)(2) = 3
sum(5)(-1) = 4
 */

function sum(a) {
    return function (b) {
        return a+b;
    }
}

console.log(sum(1)(2));
console.log(sum(5)(-1));


/*
Фильтрация с помощью функции
важность: 5
У нас есть встроенный метод arr.filter(f) для массивов. Он фильтрует все элементы с помощью функции f. Если она возвращает true, то элемент добавится в возвращаемый массив.

Сделайте набор «готовых к употреблению» фильтров:

inBetween(a, b) – между a и b (включительно).
inArray([...]) – находится в данном массиве.
Они должны использоваться таким образом:

arr.filter(inBetween(3,6)) – выбирает только значения между 3 и 6 (включительно).
arr.filter(inArray([1,2,3])) – выбирает только элементы, совпадающие с одним из элементов массива
Например:

/ .. ваш код для inBetween и inArray /
let arr = [1, 2, 3, 4, 5, 6, 7];

alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6

alert( arr.filter(inArray([1, 2, 10])) ); // 1,2
 */

function inBetween(a, b) {
    return (elem) => elem >= a && elem <= b;
}

function inArray(array) {
    return (elem) => array.includes(elem);
}

/*
function inArray(array) {
    return function (elem) {
        return array.includes(elem);
    }
}
 */

let arr = [1, 2, 3, 4, 5, 6, 7];
console.log(arr.filter(inBetween(3,6)));
console.log(arr.filter(inArray([1, 2, 10])));




/*
У нас есть массив объектов, который нужно отсортировать:

let users = [
  { name: "John", age: 20, surname: "Johnson" },
  { name: "Pete", age: 18, surname: "Peterson" },
  { name: "Ann", age: 19, surname: "Hathaway" }
];
Обычный способ был бы таким:

// по имени (Ann, John, Pete)
users.sort((a, b) => a.name > b.name ? 1 : -1);

// по возрасту (Pete, Ann, John)
users.sort((a, b) => a.age > b.age ? 1 : -1);
Можем ли мы сделать его короче, скажем, вот таким?

users.sort(byField('name'));
users.sort(byField('age'));
То есть, чтобы вместо функции, мы просто писали byField(fieldName).

Напишите функцию byField, которая может быть использована для этого.
 */

let users = [
    { name: "John", age: 20, surname: "Johnson" },
    { name: "Pete", age: 18, surname: "Peterson" },
    { name: "Ann", age: 19, surname: "Hathaway" }
];

function byField(name) {
    return (a, b) => {
        return a[name] > b[name] ? 1 : -1;
    }
}
let field = name;
users.sort(byField(field));
users.forEach(el => console.log(el[field]))

field = "age";
users.sort(byField(field));
users.forEach(el => console.log(el[field]))




/*
Армия функций
важность: 5
Следующий код создаёт массив из стрелков (shooters).

Каждая функция предназначена выводить их порядковые номера. Но что-то пошло не так…

function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i < 10) {
    let shooter = function() { // функция shooter
      alert( i ); // должна выводить порядковый номер
    };
    shooters.push(shooter);
    i++;
  }

  return shooters;
}

let army = makeArmy();

army[0](); // у 0-го стрелка будет номер 10
army[5](); // и у 5-го стрелка тоже будет номер 10
// ... у всех стрелков будет номер 10, вместо 0, 1, 2, 3...
Почему у всех стрелков одинаковые номера? Почините код, чтобы он работал как задумано.
 */

function makeArmy() {
    let shooters = [];

    let i = 0;
    while (i < 10) {
        function createShooter(i) {
            return function() {
                alert(i); // порядковый номер стрелка
            }
        }
        shooters.push(createShooter(i));
        i++;
    }

    return shooters;
}

let army = makeArmy();
army[1]();
army[5]();